#ifndef OFLUX_FLOW_FUNCTIONS
#define OFLUX_FLOW_FUNCTIONS
/*
 *    OFlux: a domain specific language with event-based runtime for C++ programs
 *    Copyright (C) 2008-2012  Mark Pichora <mark@oanda.com> OANDA Corp.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Affero General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Affero General Public License for more details.
 *
 *    You should have received a copy of the GNU Affero General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file OFluxFlowFunctions.h
 * @author Mark Pichora
 * Things that hold the compiled-in C-style lookup maps used to load the 
 * program and bind the flow to C function pointers etc when the XML is loaded.
 */

#include "OFlux.h"

namespace oflux {
namespace flow {

class Library;


class FunctionMapsAbstract {
public:
	virtual Library* libraryFactory(const char * dir, const char * name) = 0;
        virtual CreateNodeFn lookup_node_function(const char * n) const = 0;
        virtual CreateDoorFn lookup_door_function(const char * d) const = 0;
        virtual ConditionFn lookup_conditional(const char * n, int argno, const char * unionhash) const = 0;
        virtual GuardTransFn lookup_guard_translator(
		  const char * guardname
                , const char * unionhash
                , const char * hash
                , int wtype
		, bool late) const = 0;
        virtual atomic::AtomicMapAbstract * lookup_atomic_map(
		const char * guardname) const = 0;

        virtual FlatIOConversionFun lookup_io_conversion(
		  const char * from_unionhash
		, const char * to_unionhash) const = 0;
};

/**
 * @class FunctionMaps
 * @brief holds the static maps generated by the flux compiler
 * The static map lookup algorithms are linear (sub-optimal), but this
 * does not matter much.
 */
class FunctionMaps : public FunctionMapsAbstract { // data that is compiled in
public:
        FunctionMaps(ConditionalMap cond_map[],
                        ModularCreateMap create_map[],
			ModularCreateDoorMap create_door_map[],
                        GuardTransMap guard_map[],
                        AtomicMapMap atom_map[],
                        IOConverterMap ioconverter_map[]);

	virtual Library* libraryFactory(const char * dir, const char * name);
        /**
         * @brief lookup a create factory function from a table given the event name
         * @param n name of the node  
         * @return a function pointer usable to create a new event (smart pointered)
         **/
        virtual CreateNodeFn lookup_node_function(const char * n) const;
        virtual CreateDoorFn lookup_door_function(const char * d) const;

        /**
         * @brief lookup a conditional function usable on a particular input
         * @param n  name of the conditional
         * @param argno  the number of the field in the object
         * @param unionhash  OFluxUnionX hash
         * @return 
         **/
        virtual ConditionFn lookup_conditional(const char * n, int argno, const char * unionhash) const;
        /**
         * @brief lookup a guard translator function
         * @remark these functions can translate an input structure to a guard key structure
         * @param guardname name of the guard
         * @param unionhash OFluxUnionX hash (indicates the input structure)
         * @param hash is the hash result of on the expression (compiler's)
         * @param wtype is the enumerated type for the guard(Read/Exclusive/...)
         * @return the compiled function (pointer to it)
         */
        virtual GuardTransFn lookup_guard_translator(
		  const char * guardname
                , const char * unionhash
                , const char * hash
                , int wtype
		, bool late) const;

        /**
         * @brief lookup the atomic map object for the given guard 
         * @param guardname the guard name
         * @return the atomic map object
         */
        virtual atomic::AtomicMapAbstract * lookup_atomic_map(
		const char * guardname) const;

        /**
         * @brief lookup the conversion from one type union to another
         * @return a generic function that can create an object that does the job
         */
        virtual FlatIOConversionFun lookup_io_conversion(
		  const char * from_unionhash
		, const char * to_unionhash) const;
private:
        ConditionalMap *   _cond_map;
        ModularCreateMap * _create_map;
        ModularCreateDoorMap * _create_door_map;
        GuardTransMap *    _guard_trans_map;
        AtomicMapMap *     _atom_map_map;
        IOConverterMap *   _ioconverter_map;
};



} // namespace flow
} // namespace oflux




#endif // OFLUX_FLOW_FUNCTIONS
